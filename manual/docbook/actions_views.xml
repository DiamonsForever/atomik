<?xml version="1.0" encoding="UTF-8"?>
<chapter id="actions-views" xmlns="http://docbook.org/ns/docbook">
	<title>Actions and views</title>
	<sect1 id="actions-views-introduction">
		<title>Introduction</title>
		<para>
			Without using Atomik, one way of doing things would have been to create a file
			per page. The page logic (i.e. connecting to a database, handling form data...) would
			have been at the top of the file followed by the HTML. 
		</para>
		<example>
			<title>A php script, the old way</title>
			<programlisting>
				<![CDATA[
<?php
	if (count($_POST)) {
		echo 'Form data received!';
	}
?>
<form>
	<input type="text" name="data" />
	<input type="submit" value="send" />
</form>]]>
			</programlisting>
		</example>
		<para>
			This is BAD!! The application logic and the presentation layer should always be separated.
		</para>
		<para>
			Now let's imagine that rather than directly doing both part in the same file we split it.
			We would have three file: one with the logic, one with the HTML and one that include both.
		</para>
		<example>
			<title>Splitting into multiple files</title>
			<para>
				<filename>page_logic.php</filename>
			</para>
			<programlisting>
				<![CDATA[
<?php
if (count($_POST)) {
	echo 'Form data received!';
}]]>
			</programlisting>
			<para>
				<filename>page_html.php</filename>
			</para>
			<programlisting>
				<![CDATA[
<form>
	<input type="text" name="data" />
	<input type="submit" value="send" />
</form>]]>
			</programlisting>
			<para>
				<filename>page.php</filename>
			</para>
			<programlisting>
				<![CDATA[
<?php
include 'page_logic.php';
include 'page_html.php';]]>
			</programlisting>
		</example>
		<para>
			Now replace the third file (the one with the includes) with Atomik and you'll have the concept
			behind Atomik. The logic script is named an action and the html a view.
		</para>
	</sect1>
	<sect1 id="actions">
		<title>Actions</title>
		<para>
			Actions are stored in the <filename>app/actions</filename> directory. Both the action and the 
			view filename must have the same name. Action files must have the <quote>php</quote> extension.
		</para>
		<para>
			The content of the action file is free. It can be anything you want. So you just do your
			logic as you used to.
		</para>
		<note>
			Be aware that actions run in their own scope and not in the global scope as you
			might think.
		</note>
		<para>
			Variables declared in the action are forwarded to the view. If you want to keep some
			variables private (i.e. which will only be available in your action) prefixed them
			with an underscore.
		</para>
		<example>
			<title>Private variables in actions</title>
			<programlisting>
				<![CDATA[
<?php
$myPublicVariable = 'value';
$_myPrivateVariable = 'secret';]]>
			</programlisting>
		</example>
		<note>
			<para>
				You shouldn't use <function>echo</function> or write any HTML code inside an action.
				As said before, the goal of an action is to separate the logic from the presentation. Thus
				mix-in both in the action file would be a non-sense!
			</para>
			<para>
				You can use folders to organize your actions.
			</para>
		</note>
	</sect1>
	<sect1 id="views">
		<title>Views</title>
		<para>
			Views are stored in the <filename>app/views</filename> directory. The file extension is
			by default <quote>phtml</quote>.
		</para>
		<para>
			The content of the view file is, as the action file, free. It should mostly be text or 
			HTML (or any presentation content, such as XML).
		</para>
		<para>
			PHP can be used to print variables from the action or to provide presentation logic like
			loops.
		</para>
		<example>
			<title>Example view</title>
			<programlisting>
				<![CDATA[
<html>
	<head>
		<title>Example</title>
	</head>
	<body>
		<?php echo $myPublicVariable; ?>
	</body>
</html>]]>
			</programlisting>
		</example>
		<figure>
			<title>A little schema to sum up!</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata format="PNG" fileref="images/actions_views.png" />
				</imageobject>
			</mediaobject>
		</figure>
	</sect1>
	<sect1 id="layouts">
		<title>Layout</title>
		<para>
			It is common in websites that all pages share the same layout. Atomik allows you to define
			a layout that will be used with all views.
		</para>
		<para>
			The layout will be rendered after the view has been rendered. The output of the view will be
			pass to the layout as a variable named <varname>$contentForLayout</varname>. 
			Layouts are rendered the same way as views.
		</para>
		<para>
			Layouts can be placed in the <filename>app/views</filename> or <filename>app/layouts</filename> directories.
			The file extension is the same as the one for views.
		</para>
		<para>
			The layout name to use has to be defined in the <quote>layout</quote> configuration key. If the
			value is false (which is the default), no layout will be used.
		</para>
		<para>
			The layout can be disabled at runtime by calling <methodname>Atomik::disableLayout()</methodname>.
			It can later be re-enabled by passing false as argument to the same method.
		</para>
		<example>
			<title>Example layout</title>
			<para>
				A layout file named <filename>_layout.phtml</filename> in the <filename>app/views</filename> directory.
			</para>
			<programlisting>
				<![CDATA[
<html>
	<head>
		<title>My website</title>
	</head>
	<body>
		<h1>My website</h1>
		<div id="content">
			<?php echo $contentForLayout; ?>
		</div>
	</body>
</html>]]>
			</programlisting>
			<para>
				In the bootstrap file
			</para>
			<programlisting>
				<![CDATA[
Atomik::set('layout', '_layout');]]>
			</programlisting>
		</example>
		<para>
			Mutliple layouts can also be used. Just use an array instead of a string in the configuration key. Layouts will
			be rendered in reverse order (the first one in the array wrap the second, the second the third, ...).
		</para>
	</sect1>
	<sect1 id="controlling-views">
		<title>Controlling views</title>
		<sect2 id="view-extension">
			<title>View's filename extension</title>
			<para>
				The default filename's extension for views is <quote>phtml</quote> as said before. This can be change using
				the configuration key named <quote>atomik/views/file_extension</quote>.
			</para>
		</sect2>
		<sect2 id="no-render-from-action">
			<title>Do not render the view from the action</title>
			<para>
				While the action is executing, you may want to avoid rendering the associated view. This can easily be done
				by calling <methodname>Atomik::noRender()</methodname> from your action.
			</para>
		</sect2>
		<sect2 id="custom-rendering-engine">
			<title>Using a custom rendering engine</title>
			<para>
				The default rendering process only uses php's include function. You may however want to use a template engine for
				example. This is possible by specifying a callback in the <quote>atomik/views/engine</quote> configuration key.
			</para>
			<para>
				The callback will receive two parameters: the first one will be the filename and the second an array containing the
				view variables.
			</para>
			<example>
				<title>Using a custom rendering engine</title>
				<programlisting>
					<![CDATA[
function myCustomRenderingEngine($filename, $vars)
{
	// your custom engine
	return $renderedContent;
}

Atomik::set('atomik/views/engine', 'myCustomRenderingEngine');]]>
				</programlisting>
			</example>
			<para>
				The custom rendering engine will be used whenever <methodname>Atomik::render()</methodname>,
				<methodname>Atomik::renderFile()</methodname> or <methodname>Atomik::renderLayout()</methodname> is used.
			</para>
		</sect2>
	</sect1>
	<sect1 id="actions-views-programmatically">
		<title>Calling actions or views programmatically</title>
		<para>
			When executing a request, the action and/or the view associated to it are
			automatically called. You can however call other actions or render other
			views using Atomik's API.
		</para>
		<para>
			The most useful use of this it to render partial views, small part of presentation
			code that is reusable.
		</para>
		<sect2 id="executing-actions">
			<title>Executing actions</title>
			<para>
				To execute an action use the <methodname>Atomik::execute()</methodname> method. It takes
				as first argument the action name.
			</para>
			<para>
				By default, if a view with the same name is found, it is rendered and the return value
				of the <methodname>execute()</methodname> method is the view output.
			</para>
			<para>
				If no view is found or <code>false</code> is used as second argument, the return value
				is an array containing all <quote>public</quote> variables from the action.
			</para>
			<example>
				<title>Calling an action programmatically</title>
				<programlisting>
					<![CDATA[
$viewOutput = Atomik::execute('myAction');
$variables = Atomik::execute('myAction', false);]]>
				</programlisting>
			</example>
			<note>
				<para>
					Calling an action using <methodname>Atomik::execute()</methodname> does not mean an action file
					must exist. However, in this case, a view file with the same name must exists.
				</para>
			</note>
		</sect2>
		<sect2 id="rendering-views">
			<title>Rendering views and files</title>
			<para>
				To render a view use the <methodname>Atomik::render()</methodname> method.
			</para>
			<para>
				It takes as first argument the view name and optionally as second argument
				an array of key/value pairs representing variables.
			</para>
			<para>
				The method returns the view output.
			</para>
			<example>
				<title>Rendering a view programmatically</title>
				<programlisting>
					<![CDATA[
$viewOutput = Atomik::render('myView');
$viewOutput = Atomik::render('myView', array('var' => 'value'));]]>
				</programlisting>
			</example>
			<para>
				It is also possible to render any file using <methodname>Atomik::renderFile()</methodname>. It takes
				as first parameter a filename. Variables can also be passed like with <methodname>Atomik::render()</methodname>.
			</para>
		</sect2>
	</sect1>
</chapter>
