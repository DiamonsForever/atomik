<?xml version="1.0" encoding="UTF-8"?>
<!--
	Traduction par Triviak (triviak24@gmail.com)
	Non-définitive
-->
<chapter id="actions" xmlns="http://docbook.org/ns/docbook">
	<title>Actions</title>
	<sect1 id="introduction-separation-logic-presentation">
		<title>Introduction à la séparation logique/présentation</title>
		<para>
			Sans utiliser Atomik, une des façon de faire les plus utilisée pour créer une application web est de créer un fichier
			par page. La logique de la page (comprendre la connexion à la base de données, le traitement des formulaires, ...)
			doit être fait au début de chaque fichier.
		</para>
		<example>
			<title>Un seul script php : l'ancienne méthode</title>
			<programlisting>
				<![CDATA[
<?php
	if (count($_POST)) {
		echo 'Les données du formulaires ont bien été recu';
	}
?>
<form>
	<input type="text" name="data" />
	<input type="submit" value="send" />
</form>]]>
			</programlisting>
		</example>
		<para>
			Cette technique est très mauvaise ! En effet, la logique et le présentation doivent être toujours séparées.
		</para>
		<para>
			Maintenant, imaginons que nous vouillons désormais séparer l'unique fichier pour qu'il respecte les couches d'abstractions. Nous allons donc devoir le diviser.
			Nous aurons donc trois fichiers : un comportant la logique, l'autre l'HTML, et enfin une dernier qui inclura ces deux fichiers.
		</para>
		<example>
			<title>La division en plusieurs fichiers</title>
			<para>
				<filename>page_logic.php</filename>
			</para>
			<programlisting>
				<![CDATA[
< ?php
if (count($_POST)) {
	echo 'Les données du formulaires ont bien été recu';
}]]>
			</programlisting>
			<para>
				<filename>page_html.php</filename>
			</para>
			<programlisting>
				<![CDATA[
<form>
	<input type="text" name="data" />
	<input type="submit" value="send" />
</form>]]>
			</programlisting>
			<para>
				<filename>page.php</filename>
			</para>
			<programlisting>
				<![CDATA[
< ?php
include 'page_logic.php';
include 'page_html.php';]]>
			</programlisting>
		</example>
		<para>
			Maintenant, il suffit d'imaginer que Atomik joue le rôle du troisième fichier (celui avec les deux includes). Avec cette exemple, vous pouvez facilement comprendre
			le concept qui est derrière Atomik. Les parties logiques sont appelées actions et le html est appelé vue.
		</para>
	</sect1>
	<sect1 id="action-files">
		<title>Les fichiers d'actions</title>
		<para>
			Les actions doivent être situées dans le répertoire <filename>app/actions</filename>. Les deux fichiers, action et vue,
			doit avoir le même nom. De plus, les actions doivent avoir l'extension <quote>php</quote>.
			Si le nom d'une action ou d'une vue commence par un underscore, alors l'action ne sera pas disponible par l'url.
		</para>
		<para>
			Il n'y a aucune exigence concernant votre fichier action. Il peut contenir tout ce que bon vous semble.
		</para>
		<note>
			Soyez conscient que les actions sont éxécutées dans leurs propre contexte et non dans le contexte global comme
			vous pourrez le croire.
		</note>
		<para>
			Les variables déclarées dans les actions sont directement expédiées dans la vue. Si vous voulez conserver des variables privées,
			(lorsque vous ne devez pas les afficher), vous devrez ajouter un underscore au début du nom de la variable.
		</para>
		<example>
			<title>Les variables prvées dans le fichier d'action</title>
			<programlisting>
				<![CDATA[
< ?php
$myPublicVariable = 'value';
$_myPrivateVariable = 'secret';]]>
			</programlisting>
		</example>
		<note>
			<para>
				Vous ne devez pas avoir à utiliser la fonction <function>echo</function> ou du quelconque code HTML à l'intérieur du fichier d'action.
				Comme il a été dit avant, le fichier d'action n'est pas concu pour cela, c'est le rôle de la vue.
			</para>
			<para>
				Si vous voulez quitter votre application, au lieu d'utiliser <function>exit()</function>, préférer
				<methodname>Atomik::end()</methodname> pour qu'Atomik puisse quitter votre application "proprement".
			</para>
		</note>
		<para>
			Vous pouvez utiliser des dossiers pour organiser vos actions. Dans ce cas, les vues doivent aussi avoir la même
			structure de dossiers. Vous pouvez créer une action <quote>index</quote> (<filename>index.php</filename>)
			à l'intérieur du dossier. Ce sera alors la page d'accueil de ce dossier, ou module. Les vues suivent aussi ce principe.
		</para>
		<example>
			<title>Les actions et les dossiers</title>
			<programlisting>
				<![CDATA[
app/actions/users.php           <- sera utiliser si url = /users
app/actions/users/index.php     <- sera utiliser si url = /users ET SI app/actions/users.php n'existe pas
app/actions/users/messages.php  <- sera utiliser si url = /users/messages quelque soit la page par défaut]]>
			</programlisting>
		</example>
	</sect1>
	<sect1 id="actions-rest">
		<title>Les actions et les méthodes HTTP</title>
		<para>
			Atomik vous offre la possibilité de créer plusieurs fichiers pour une seule action, chacun peut être ciblé à l'aide d'une url spécifique.
			Cela permet au site web d'être plus facile à construire.
		</para>
		<sect2 id="actions-rest-targeting">
			<title>Cibler une méthode HTTP</title>
			<para>
				Une méthode spécifiant une action doit être ajouter à la fin du nom de la méthode. Par exemple,
				si vous avez une action <quote>user</quote> et que vous voulez qu'elle cible une méthode de type POST, vous devrez créer
				fichier nommé <filename>user.post.php</filename>. Avec la méthode put, il aurait été <filename>user.put.php</filename>. 
				Tous ces fichiers doivent être situés dans le dossier des actions.
			</para>
			<para>
				Vous pouvez créer des fichiers d'actions globales (dans le précédant exemple : <filename>user.php</filename>)
				tant que vous n'avez pas encore éxécuté une méthode d'action spécifique. Les variables provenant de l'action globale
				sont disponible dans ce fichier spécifique.
			</para>
			<para>
				La méthode http actuelle est disponible dans la clé de configuration <quote>app/http_method</quote>
			</para>
		</sect2>
		<sect2 id="actions-rest-allowed-override">
			<title>Autoriser les méthodes et réécrire leurs requêtes</title>
			<para>
				L'autorisation des méthodes HTTP est définie dans la clé <quote>app/allowed_http_methods</quote>. Par défaut, toutes les méthodes disponible
				dans l'application sont listées, mais vous pouvez si vous le souhaité réduire cette liste.
			</para>
			<para>
				Beaucoup de clients ne gèrent pas correctement les méthodes HTTP (Par exemple Flex). Pour cela, 
				il est possible de réécrire les requètes des méthodes utilisant un initinéraire comme paramètre (qui peut être un paramètre GET).
				Le nom du paamètre par défaut est <quote>_method</quote>. Il peut être changé dans 
				<quote>app/http_method_param</quote>. Il est aussi possible de les désactiver en plaçant
				false à la place de la chaîne de caractère.
			</para>
		</sect2>
	</sect1>
	<sect1 id="actions-classes">
		<title>Utiliser des classes pour définir des actions</title>
		<para>
			Depuis Atomik 2.2, vous pouvez utiliser des classes pour vos fichiers d'action. Cette organisation peut être particulierement intéressante dans
			le cas d'action complexe.
		</para>
		<tip>
			Par souci de cohérence, vous devez choisir, dès le début de votre projet d'utiliser ou non des classes.
		</tip>
		<para>
			Lorsque vous éxécuter des action, Atomik va chercher une classe appelée <quote>{actionName}Action</quote>.
			Si elle existe et qu'elle possède une méthode static appelée <methodname>execute()</methodname>, elle sera imédiatement appelée.
			
		</para>
		<example>
			<title>Utiliser une classe pour une action</title>
			<para>
				dans un fichier d'action appelé <filename>index.php</filename>.
			</para>
			<programlisting>
				<![CDATA[
class IndexAction
{
	public static function execute()
	{
	}
}]]>
			</programlisting>
		</example>
		<para>
			Si le fichier d'action est situé dans un sous-dossier, le nom de la classe doit respecté les conventions PEAR.
		</para>
		<para>
			Si l'action est en train de ciblé une méthode HTTP spécifique, le nom de la méthode doit être ajouter avant
			le mot-clé Action dans le nom de la classe.
		</para>
		<example>
			<title>Utilisation d'une classe dans une action située dans un sous-dossier ou ciblée par une méthode HTTP</title>
			<para>
				Dans un fichier d'action situé à <filename>users/list.php</filename>, le nom de la classe doit être
				<classname>Users_ListAction</classname>.
			</para>
			<para>
				Si une action est ciblée par une méthode POST, le nom de la classe devra être
				<classname>Users_ListPostAction</classname>.
			</para>
		</example>
		<para>
			Pour définir des variables de vues, vous avez deux possibilitées. Atomik va automatiquement mettre à la disposition
			les méthodes static à moins qu'elle ne commence par un underscore).
			La méthode <methodname>execute()</methodname> peut retourner aussi un tableau associatif clé/valeur
			qui sera disponible comme variable dans la vue.
		</para>
		<example>
			<title>Mise en place de variables de vue avec les classes action</title>
			<programlisting>
				<![CDATA[
class IndexAction
{
	public static $foo = 'foo';
	
	public static function execute()
	{
		return array('bar' => 'bar');
	}
}]]>
			</programlisting>
			<para>
				<varname>$foo</varname> et<varname>$bar</varname> seront disponible dans la vue.
			</para>
		</example>
	</sect1>
	<sect1 id="actions-programmatically">
		<title>Appeler une action automatiquement</title>
		<para>
			Lorsque vous éxécutez une requète, l'action et/ou la vue associée sont automatiquement appelées.
			Vous pouvez cependant appeler une autre action en utilisant l'API d'Atomik.
		</para>
		<para>
			Pour éxécuter une action, il faut utiliser la méthode <methodname>Atomik::execute()</methodname>. Celle-ci
			prend comme premier argument le nom de l'action.
		</para>
		<para>
			Par défaut, si une vue avec le même nom est trouvée, elle sera affichée et la valeur de retour
			de la méthode  <methodname>execute()</methodname> sera la sortie de cette vue.
		</para>
		<para>
			Si la vue n'est pas trouvée, une chaîne de caractère vide sera retournée. Si <code>false</code> est utilisé comme second argument,
			la valeur de retour retournée sera un tableau contenant toutes les variables <quote>public</quote> provenant de l'action.
		</para>
		<example>
			<title>Appel d'une action</title>
			<programlisting>
				<![CDATA[
$viewOutput = Atomik::execute('myAction');
$variables = Atomik::execute('myAction', false);]]>
			</programlisting>
		</example>
		<note>
			<para>
				Pour apeler une action, l'utilisation de <methodname>Atomik::execute()</methodname> ne signifie pas que le fichier d'action doit
				exister. Cependant, dans ce cas, un fichier de vue avec le même nom doit exister. Sinon, c'est la valeur false
				qui est retournée.
			</para>
		</note>
		<para>
			Des actions éxécutées par cette méthode seront influencées par les méthodes HTTP. Vous pouvez spécifier des méthodes
			par appendinf? pour le nom de la méthode. Une action globale sera alors éxécutée.
		</para>
		<example>
			<title>Appel d'une action par une méthode spécifique</title>
			<programlisting>
				<![CDATA[
$viewOutput = Atomik::execute('myAction.post');]]>
			</programlisting>
		</example>
	</sect1>
</chapter>
