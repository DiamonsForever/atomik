<?xml version="1.0" encoding="UTF-8"?>
<!--
	Traduction par Triviak (triviak24@gmail.com)
	Non-définitive
-->
<chapter id="views-layouts" xmlns="http://docbook.org/ns/docbook">
	<title>Les vues et leurs organisations</title>
	<sect1 id="views">
		<title>Les vues</title>
		<para>
			Les vues sont placées dans le répertoire <filename>app/views</filename>. Leurs extensions
			sont par défaut <quote>phtml</quote>.
		</para>
		<para>
			Le contenu de ces fichiers est libre, tout comme les actions. Atomik recommande tout de même,
			pour respecter la séparation entre actions et vues, d'y placer un maximum de texte ou d'HTML
			(ou encore un autre langage tel que le XML).
		</para>
		<para>
			PHP peut tout de même être utilisé pour afficher des variables ou encore pour l'utilisation
			de boucles.
		</para>
		<example>
			<title>Exemple d'une vue</title>
			<programlisting>
				<![CDATA[
<html>
	<head>
		<title>Exemple</title>
	</head>
	<body>
		<?= $myPublicVariable; ?>
	</body>
</html>]]>
			</programlisting>
		</example>
		<tip>
		   Si votre configuration le permet, il est préférable d'utiliser les shorts tag dans la vue pour avoir une meilleur lisibilité.
		</tip>
		<figure>
			<title>Un petit schéma pour résumer</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata format="PNG" fileref="images/actions_views.png" />
				</imageobject>
			</mediaobject>
		</figure>
	</sect1>
	<sect1 id="helpers">
		<title>Les modèles de vues</title>
		<para>
			Lorsque vous créez vos vues, vous aurez parfois besoin de réaliser plusieurs fois la même chose, ou quelque chos qui s'y rapproche fortement, comme exemple
			le formatage d'une date. Ce type de modèle sert exactement à cela : il s'agit d'une fonction qui sera éxecutée dans votre vue, <function>format_date()</function>
			par exemple.
		</para>
		<sect2 id="creating-helpers">
			<title>Créer des modèles de vue</title>
			<para>
				Les modèles de vue, dans Atomik sont placés dans le répertoire <filename>app/helpers</filename>. 
				Notre modèle : <filename>app/helpers</filename> devra donc être situé dans <filename>app/helpers/format_date.php</filename>.
				Cet emplacement peut-être changé en utilisant la clé <quote>atomik/dirs/helpers</quote>.
			</para>
			<para>
				Il y a deux voies pour définir un modèle de vue : comme une fonction ou comme une classe. Si vous utilisez la fonction,
				il suffit simplement de mettre le même nom de fichier que du helper. Dans le cas de notre modèle <quote>format_date</quote>,
				le nom de la fonction doit être <function>format_date()</function>.
				Mais si vous voulez plutôt opter pour une classe, car ce que vous voulez réaliser est plus complexe. Alors, il faut que le nom
				de la classe soit nommé sans underscore et en commençant par une majuscule, puis mettre un <quote>Helper</quote> en suffixe. Dans notre exemple, ce sera
				<classname>FormatDateHelper</classname>. Cette clase aura alors besoin d'une méthode appelée comme le nom de la classe, sans le helper, et sans la majuscule du début.
				Dans notre cas, notre méthode s'appelera <methodname>formatDate()</methodname>.
			</para>
			<example>
				<title>Créer un modèle</title>
				<para>
					En tant que fonction
				</para>
				<programlisting>
					<![CDATA[
function format_date($date)
{
	// coder le formatge
	return $date;
}]]>
				</programlisting>
				<para>
					En tant que classe
				</para>
				<programlisting>
					<![CDATA[
class FormatDateHelper
{
	public function formatDate($date)
	{
		// coder le formatge
		return $date;
	}
}]]>
				</programlisting>
			</example>
		</sect2>
		<sect2 id="using-helpers">
			<title>Utiliser le modèle</title>
			<para>
				Les modèles de vues peuvent être appelés à partir de n'importe quel fichier qui peut-être affiché.
				Ceci pour dire que les vues, les layouts (ou modèles) ainsi que les fichiers d'affichage utiliseront <methodname>Atomik::renderFile</methodname>.
				Ils peuvent avoir accès aux méthodes à l'aide de l'instance <varname>$this</varname>. Les modèles de vues sont automatiquement inclus.
			</para>
		    <note>
			Les modèles de vues peuvent être utilisés dans les actions, mais ils ont été créés dans le but de l'utiliser dans les vues.
		    </note>
			<example>
				<title>Appeler un modèle</title>
				<programlisting>
					<![CDATA[
<span class="date"><?= $this->format_date('01-01-2009') ?></span>]]>
				</programlisting>
			</example>
		</sect2>
	</sect1>
	<sect1 id="layouts">
		<title>Layout</title>
		<para>
			Il est courant, dans les sites web, que toutes les pages partagent un même layout (appelé aussi modèle, patron, ...). Atomik vous permet alors
			de définir un layout qui sera utiliser automatiquement dans toutes les vues.
		</para>
		<para>
			Le layout sera mise en place une fois que la vue aura été terminée. La sortie de la vue passera donc par
			une variable appelée : <varname>$contentForLayout</varname>. 
			Les layouts peuvent être créés en suivant la même méthode que les vues.
		</para>
		<para>
			Les layouts peuvent être placés dans les répertoires <filename>app/views</filename> ou <filename>app/layouts</filename>
			L'extension de ce fichier est le même que celui des vues.
		</para>
		<para>
			Le nom du layout utilisé peut-être défini dans la clé de configuration <quote>app/layout</quote>. Si la valeur est
			false (par défaut), il ne sera pas chargé.
		</para>
		<para>
			Le layout peut-être desactivé pendant l'exécution du sccript à l'aide de la méthode <methodname>Atomik::disableLayout()</methodname>.
			Il pourra alors être réactivé en passant false à l'argument de cette même méthode.
		</para>
		<example>
			<title>Exemple de Layout</title>
			<para>
				Créons un fichier nommé <filename>_layout.phtml</filename> dans le répertoire <filename>app/views</filename>.
			</para>
			<programlisting>
				<![CDATA[
<html>
	<head>
		<title>Mon site web</title>
	</head>
	<body>
		<h1>Mon site web</h1>
		<div id="contenu">
			<?= $contenuDuLayout; ?>
		</div>
	</body>
</html>]]>
			</programlisting>
			<para>
				Dans le fichier d'armorçage
			</para>
			<programlisting>
				<![CDATA[
Atomik::set('app/layout', '_layout');]]>
			</programlisting>
		</example>
		<para>
			Plusieur layouts peuvent être utilisés. Pour cela, il suffit de placer un tableau dans la clé de configuration à la place d'une chaine de caractères. Les layouts seront
			alors afficher dans l'ordre inverse (le premier envelopera le deuxième qui enveloppera le troisième, ...)
		</para>
	</sect1>
	<sect1 id="view-contexts">
		<title>Les contextes de vues</title>
		<para>
			Parfois, on a besoin d'afficher des contenus de différents formats. Plutôt que de créer de multiples actions qui font la même chose,
			Atomik intégre une fonctionnalité permettant de créer des vues pour chaque type de contenu. Ceci est appelé les contextes de vue. La vue
			affichée dépendra alors du contexte.
		</para>
		<para>
			Ces contextes sont définis en utilisant les paramètres de routage. Par défaut, il est appelé <quote>format</quote>. Il peut être changé
			dans <quote>app/views/context_param</quote>. Comme il a été dit dans le chapitre portant sur les urls, le format des paramètres
			est par défaut l'extension du fichier. Ce qui signifie que l'utilisation d'une url comme <link>index.xml</link> résultera de l'utilisation du format xml.
		</para>
		<para>
			Le contexte par défaut de la vue est le <quote>html</quote> mais il peut-être changé dans <quote>atomik/views/default_context</quote>.
		</para>
		<para>
			Pour créer une vue pour un contexte donné, il suffit de mettre en suffixe le nom du contexte sur le nom de la vue, comme une extension. Par exemple, 
			nous avons une vue <quote>article</quote>. Pour avoir le contexte xml, on devra mettre <filename>article.xml.phtml</filename>.
			Certain contexte n'ont pas besoin de suffixe comme <quote>html</quote>.
		</para>
		<para>
			En fonction du contexte de la vue, le layout peut-être désactiver et l'asociation contenu-type peut-être modifée. Le préfixe du fichier peut
			aussi être spécifié. Tout ceci peut-être effectué dans <quote>app/views/contexts</quote>.
		</para>
		<example>
			<title>Créer une vue personnalisée</title>
			<para>
				Créons le contexte <quote>rdf</quote>.
			</para>
			<programlisting>
				<![CDATA[
Atomik::set('app/views/contexts/rdf', array(    // le nom du contexte, par exemple le nom du fichier dans l'url
	'prefix'        => 'rdf',                   // le préfixe de l'extension de la vue (mettre false pour ne pas en avoir)
	'layout'        => false,                   // Si vous voulez activer le layout
	'content-type'  => 'application/xml+rdf'    // le type de contenu
));]]>
			</programlisting>
			<para>
				Maintenant, vou pouvez appeler une url comme <link>http://example.com/article.rdf</link>. Dans ce cas le nom de la vue
				sera <filename>article.rdf.phtml</filename>, le layout devra être desactivé et le type de contenu devra être
				<quote>application/xml+rdf</quote>.
			</para>
		</example>
		<para>
			Si un contexte de vue n'est pas défini dans <quote>app/views/contexts</quote>, le préfixe du fichier sera alors le nom du contexte,
			le layout devra être désactivé et le type de réponse sera  <quote>text/html</quote>.
		</para>
		<para>
			Par défaut, il y a quatres contextes définis : html, ajax, xml et json. Le context ajax est le même que celui d'html avec
			le layout désactivé. Les deux derniers lorsque le layout est activé, doivent mettre le type de contenu aproprié.
		</para>
	</sect1>
	<sect1 id="controlling-views">
		<title>Les controlleurs de vues</title>
		<sect2 id="view-extension">
			<title>L'extensions des fichiers de vues</title>
			<para>
				Par défaut, l'extension des fichiers de vues est <quote>phtml</quote> comme il a déjà été dit. Ceci peut être changé
				Ceci peut être changé en utilisant la clé de configuration <quote>app/views/file_extension</quote>.
			</para>
		</sect2>
		<sect2 id="no-render-from-action">
			<title>Ne pas afficher une vue</title>
			<para>
				Tant que l'action est en cours d'éxécution, vous avez la possibilité d'annuler l'affichage de la vue.
				Pour cela, il suffit d'appeler la méthode <methodname>Atomik::noRender()</methodname> depuis votre fichier d'action.
			</para>
		</sect2>
		<sect2 id="modify-associated-view">
			<title>Modifier une vue correpondante à une action</title>
			<para>
				Tant que l'action est en cours d'éxécution, vous avez la possibilité de changer de vue correpondante à tout moment.
				Dans ce cas, vous pouvez utiliser <methodname>Atomik::setView()</methodname> dans votre action. Elle prends un unique argument : 
				le nom de la vue.
			</para>
		</sect2>
		<sect2 id="custom-rendering-engine">
			<title>Utilisation d'un moteur de rendu personnalisé</title>
			<para>
				Le moteur de rendu par défaut est seulement utilisé par les fonctions incluses par PHP. Vous pouvez cependant utiliser votre moteur de template.
				Pour cela, vous devez spécifier un callback dans la clé de configuration <quote>app/views/engine</quote>
			</para>
			<para>
				Le fonction calback recevra 2 paramètres : le nom du fichier et un tableau associatif contenant les variables spécifiques de la vue.
			</para>
			<example>
				<title>L'utilisation d'un moteur de rendu personnalisé</title>
				<programlisting>
					<![CDATA[
function myCustomRenderingEngine($filename, $vars)
{
	// Votre propre moteur de rendu personnalisé
	return $renderedContent;
}

Atomik::set('app/views/engine', 'myCustomRenderingEngine');]]>
				</programlisting>
			</example>
			<para>
				Votre moteur de rendu personnalisé sera utilisé à chaque fois que <methodname>Atomik::render()</methodname>,
				<methodname>Atomik::renderFile()</methodname> ou <methodname>Atomik::renderLayout()</methodname> sera utilisées.
			</para>
		</sect2>
	</sect1>
	<sect1 id="views-programmatically">
		<title>Personnaliser automatiquement vos vues</title>
		<para>
			Lorsque vous éxécutez une requète, l'action et/ou la vue associée est automatiquementt
			appelées. Vous pouvez cependant modifier la vue pour une autre en utilisant l'API d'Atomik.
		</para>
		<para>
			L'utilité principal d'utiliser ceci pour afficher vos vues est que la partie du code
			peut-être réutilisée.
		</para>
		<para>
			Pour permuter une vue, utilisez la méthode <methodname>Atomik::render()</methodname>.
		</para>
		<para>
			Elle prend en argument le nom de la vue, et optionnellement, un tableau associatif de clé/valeur
			repésentant les variables.
		</para>
		<example>
			<title>Personnalisons notre vues</title>
			<programlisting>
				<![CDATA[
$viewOutput = Atomik::render('maVue');
$viewOutput = Atomik::render('maVue', array('var' => 'value'));]]>
			</programlisting>
		</example>
		<para>
			Il est possible d'afficher un quelconque fichier avec la méthode <methodname>Atomik::renderFile()</methodname>.
			Celle-ci prend un paramètre : le nom du fichier. Les variables peuvent aussi être passées comme avec <methodname>Atomik::render()</methodname>.
		</para>
		<note>
			Vous pouvez également afficher une vue contextuelle en ajoutant l'extension du fichier au nom de la vue.
		</note>
	</sect1>
</chapter>
