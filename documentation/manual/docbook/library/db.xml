<?xml version="1.0" encoding="UTF-8"?>
<chapter id="db" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>Db</title>
	<para>
		The Db component provides database features over PDO. Thus, it is advice to know
		how to use PDO before using it. Check out <link xlink:href="http://php.net/pdo">http://php.net/pdo</link> 
		for more information.
	</para>
	<sect1 id="db-manager">
		<title>Atomik_Db and Instances</title>
		<para>
			The Db component allows you to manage as many connections as you want. Each connection is bound to a manager
			class called an instance of type <classname>Atomik_Db_Instance</classname>.
		</para>
		<para>
			The <classname>Atomik_Db</classname> class can be used to manage all instances and also offers a way to
			access statically all methods from a default instance.
		</para>
		<sect2 id="db-manager-instances">
			<title>Managing instances</title>
			<para>
				Each instances managed by <classname>Atomik_Db</classname> must be named.
			</para>
			<para>
				You can add instances to <classname>Atomik_Db</classname> using <methodname>addAvailableInstance()</methodname>.
				The first argument is the name and the second the instance object.
			</para>
			<example>
				<title>Adding instances to <classname>Atomik_Db</classname></title>
				<programlisting>
					<![CDATA[
Atomik_Db::addAvailableInstance('db1', $instance);]]>
				</programlisting>
			</example>
			<para>
				You can then check if an instance is available using <methodname>isInstanceAvailable()</methodname> and
				retrieve all instances using <methodname>getAvailableInstances()</methodname>.
			</para>
			<para>
				Finally, it is possible to create and register an instance using <methodname>createInstance()</methodname>.
				It takes as first argument the instance name and then the same as argument as <classname>Atomik_Db_Instance</classname>'s
				constructor. There is a fifth parameter, which is true by default, that, if true, will set the new instance as the
				default one.
			</para>
			<example>
				<title>Creating instances using <classname>Atomik_Db</classname></title>
				<programlisting>
					<![CDATA[
$instance = Atomik_Db::createInstance('db1', $dsn, $username, $password);]]>
				</programlisting>
			</example>
		</sect2>
		<sect2 id="db-manager-default">
			<title>Using Atomik_Db and a default instance</title>
			<para>
				All <classname>Atomik_Db_Instance</classname> methods are available as static methods on the 
				<classname>Atomik_Db</classname> class. Calling these methods will forward the call to the
				default instance.
			</para>
			<para>
				The default instance can be set using <methodname>Atomik_Db::setInstance()</methodname>. It takes
				as argument an instance name or object. It can be retrieve using <methodname>getInstance()</methodname>.
			</para>
			<example>
				<title>Setting a default instance and using static methods</title>
				<programlisting>
					<![CDATA[
Atomik_Db::setInstance($instance);
$result = Atomik_Db::findAll('table');]]>
				</programlisting>
			</example>
			<para>
				Thus, all methods covered in the next section about instances can also be used on the 
				<classname>Atomik_Db</classname> class.
			</para>
		</sect2>
	</sect1>
	<sect1 id="db-instances">
		<sect2 id="db-instances-connection">
			<title>Connecting to a database</title>
			<para>
				<classname>Atomik_Db_Instance</classname> supports lazy connections. This means that it will connect to
				the database only if a query is performed.
			</para>
			<para>
				Connection information can be defined when creating the object.
			</para>
			<example>
				<title>Creating a <classname>Atomik_Db_Instance</classname> object</title>
				<programlisting>
					<![CDATA[
$instance = new Atomik_Db_Instance($dsn, $username, $password);]]>
				</programlisting>
			</example>
			<para>
				You can then force the connection by calling <methodname>Atomik_Db_Instance::connect()</methodname>
				without any arguments.
			</para>
			<para>
				If you created a <classname>Atomik_Db_Instance</classname> object without any constructor arguments,
				you can use <methodname>connect()</methodname> to connect to the database.
			</para>
			<example>
				<title>Connecting to a database using <methodname>connect()</methodname></title>
				<programlisting>
					<![CDATA[
$instance->connect('mysql:host=localhost;dbname=mydb', 'root', '');]]>
				</programlisting>
			</example>
			<tip>
				The <classname>PDO</classname> object which <classname>Atomik_Db_Instance</classname> uses can be accessed
				using the pdo property.
			</tip>
		</sect2>
		<sect2 id="db-instances-query">
			<title>Querying the database</title>
			<sect3 id="db-instances-query-pdo">
				<title>Using PDO-like methods</title>
				<para>
					The <classname>Atomik_Db_Instance</classname> class provides three alias methods to PDO methods:
					<methodname>query()</methodname>, <methodname>exec()</methodname> and <methodname>prepare()</methodname>.
					The two last one behave exactly the same way. However <methodname>query()</methodname> is a little
					different.
				</para>
				<para>
					Under the hood it creates a PDO statement using prepare and executes it. Thus, the method also allows
					an additional argument which can contains an array to pass to the execute call of the statement.
				</para>
				<example>
					<title>Using <methodname>Atomik_Db_Instance::query()</methodname></title>
					<programlisting>
						<![CDATA[
$results = $instance->query('select * from posts');
$results = $instance->query('select * from posts where id=?', array(1));]]>
					</programlisting>
				</example>
				<example>
					<title>Using other PDO methods with <classname>Atomik_Db_Instance</classname></title>
					<programlisting>
						<![CDATA[
$statement = $instance->prepare('select * from posts');
$statement->execute();

$results = $instance->exec("insert into posts (content) values ('my new post')");]]>
					</programlisting>
				</example>
			</sect3>
			<sect3 id="db-instances-query-find">
				<title>Using <quote>find</quote> methods</title>
				<para>
					The <classname>Atomik_Db_Instance</classname> class also provides two powerful methods to query the database:
					<methodname>find()</methodname> and <methodname>findAll()</methodname>. They are
					exactly the same but the first one will return only one record whereas the second all of them.
				</para>
				<para>
					Conditions are specified as an associative array. The keys are database fields.
					An sql string can also be used instead of the array.
				</para>
				<example>
					<title>Finding records from one table</title>
					<programlisting>
						<![CDATA[
// all records from the posts table
$results = $instance->findAll('posts');

// only records from the author 3
$results = $instance->findAll('posts', array('author' => 3));
// or
$results = $instance->findAll('posts', 'author = 3');]]>
					</programlisting>
				</example>
				<para>
					You can also specify an order by and a limit clause. Respectively as the third and fourth arguments.
				</para>
				<example>
					<title>Finding records with order by and limit clauses</title>
					<programlisting>
						<![CDATA[
// all records from the posts table ordered by creation_date
$results = $instance->findAll('posts', null, 'creation_date ASC');

// the first 10 records from the posts table
$results = $instance->findAll('posts', null, '', '10');

// the first 10 records from the posts table ordered by creation_date
$results = $instance->findAll('posts', null, 'creation_date' , '10');

// records 10 to 20 from the posts table
$results = $instance->findAll('posts', null, '', '10, 10');]]>
					</programlisting>
				</example>
				<example>
					<title>Working with the result of find methods</title>
					<programlisting>
						<![CDATA[
$posts = $instance->findAll('posts');
foreach ($posts as $post) {
	echo $post['title'];
	echo $post['content'];
}]]>
					</programlisting>
				</example>
			</sect3>
			<sect3 id="db-instances-count">
				<title>Counting records</title>
				<para>
					You can perform SELECT COUNT(*) queries using <methodname>Atomik_Db_Instance::count()</methodname>.
					This method takes the same parameters as <methodname>Atomik_Db_Instance::find()</methodname>.
				</para>
				<example>
					<title>Counting records from one table</title>
					<programlisting>
						<![CDATA[
$numberOfPosts = $instance->count('posts');]]>
					</programlisting>
				</example>
			</sect3>
		</sect2>
		<sect2 id="db-instances-dml">
			<title>Manipulating data</title>
			<sect3 id="insert">
				<title>Insert</title>
				<para>
					The <methodname>Atomik_Db_Instance::insert()</methodname> method can be use to insert data into the database. It takes
					as first argument the table name and as second an associative array where keys are fields name.
				</para>
				<example>
					<title>Inserting data into the database</title>
					<programlisting>
						<![CDATA[
$instance->insert('posts', array('title' => 'my first posts', 'content' => 'hello world'));
// will execute: insert into posts (title, content) values('my first post', 'hello world')]]>
					</programlisting>
				</example>
				<para>
					All values are automatically escaped.
				</para>
			</sect3>
			<sect3 id="update">
				<title>Update</title>
				<para>
					<methodname>Atomik_Db_Instance::update()</methodname> works pretty much the same. However it takes as the last argument
					an array of conditions (the same way as in find methods) or an sql string.
				</para>
				<example>
					<title>Updating data</title>
					<programlisting>
						<![CDATA[
$instance->update('posts', array('content' => 'updated hello world'), array('id' => 1));
// will execute: update posts set content = 'updated hello world' where posts.id = 1]]>
					</programlisting>
				</example>
			</sect3>
			<sect3 id="delete">
				<title>Delete</title>
				<para>
					Finally, the <methodname>Atomik_Db_Instance::delete()</methodname> works the same as find methods (without the order by and
					limit arguments).
				</para>
				<example>
					<title>Deleting data</title>
					<programlisting>
						<![CDATA[
$instance->delete('posts', array('id' => 1));
// will execute: delete from posts where posts.id = 1

$instance->delete(array('posts', array('id' => 1)));
// will execute: delete from posts where posts.id = 1

$instance->delete('posts', 'id = 1');
// will execute: delete from posts where id = 1]]>
					</programlisting>
				</example>
			</sect3>
		</sect2>
	</sect1>
	<sect1 id="db-query">
		<title>Creating queries using Atomik_Db_Query</title>
		<para>
			<classname>Atomik_Db_Query</classname> provides a way to create sql queries without writing a line of sql!
			<classname>Atomik_Db_Instance</classname> uses <classname>Atomik_Db_Query</classname> under the hood for all its
			requests.
		</para>
		<para>
			<classname>Atomik_Db_Query</classname> can be used independently of instances and only requires a PDO object
			to be executed. The result of such a query is returned as an <classname>Atomik_Db_Query_Result</classname> object.
			This object manages a <classname>PDOStatement</classname>.
		</para>
		<note>
			As <classname>Atomik_Db_Instance</classname> is using <classname>Atomik_Db_Query</classname>, all results returned
			by its methods are expressed using <classname>Atomik_Db_Query_Result</classname>.
		</note>
		<sect2 id="db-query-create">
			<title>Building queries</title>
			<para>
				Using <classname>Atomik_Db_Query</classname> can be thought as similar to writing sql queries. Methods can
				be chained so that the flow of a query is not disrupted.
			</para>
			<example>
				<title>Selecting data using <classname>Atomik_Db_Query</classname></title>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->where('id = ?', 1);]]>
				</programlisting>
			</example>
			<para>
				<methodname>select()</methodname> takes as arguments which fields to select.
			</para>
			<para>
				<methodname>from()</methodname> takes as argument a table name. This method can be called
				several times to query from multiple tables. An alias can be specified as second argument.
			</para>
			<para>
				<methodname>where()</methodname> can be used in multiple ways. As shown above, it can be an sql string.
				This string can contain positional parameter which can then be specified as method arguments.
			</para>
			<para>
				The method can also take as first argument an array where keys are field's name. All values will be
				automatically escaped. This can be prevented using the <methodname>expr()</methodname> method of the query
				object. It takes as argument the value which won't be escaped.
			</para>
			<para>
				Multiple call to <methodname>where()</methodname> can be performed. They will be concatenated using the AND
				sql operator. If you want to use OR instead you can use the <methodname>orWhere()</methodname> method.
			</para>
			<example>
				<title>Specifying where clauses</title>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->where('id = 1');]]>
				</programlisting>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->where('name = ?', 'peter')->where('password = ?', 'foo');]]>
				</programlisting>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->where('join_date = ?', $query->expr('NOW()'));]]>
				</programlisting>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->where(array('id' => 1))->orWhere('id = 2');]]>
				</programlisting>
			</example>
			<para>
				<classname>Atomik_Db_Query</classname> also allows you to perform joins using <methodname>join()</methodname>,
				group by using <methodname>groupBy()</methodname>. You can also specify an having clause using
				<methodname>having()</methodname> (which works the same as <methodname>where()</methodname>);
			</para>
			<para>
				An order by clause can be specified using <methodname>orderBy()</methodname> which takes a field name as first
				argument and optionally the direction (ASC or DESC) as second.
			</para>
			<example>
				<title>Specifying an order by clause</title>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->orderBy('name');]]>
				</programlisting>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->orderBy('name ASC');]]>
				</programlisting>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->orderBy('name', 'DESC');]]>
				</programlisting>
			</example>
			<para>
				Finally, you can specify a limit clause which takes either a single argument which will be the length or two
				arguments where the first one will be the offset and the second the length.
			</para>
			<example>
				<title>Specifying a limit clause</title>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->limit(10);]]>
				</programlisting>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->select()->from('users')->limit(10, 10);]]>
				</programlisting>
			</example>
			<para>
				<classname>Atomik_Db_Query</classname> can also be used to generate ddl statements (insert, update and delete) using
				the same approach. 
			</para>
			<example>
				<title>Building ddl statement</title>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->insertInto('users')->values(array('username' => 'peter', 'password' => 'foo'));]]>
				</programlisting>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->update('users')->set(array('password' => 'bar'))->where('username = ?', 'peter');]]>
				</programlisting>
				<programlisting>
					<![CDATA[
$query = new Atomik_Db_Query();
$query->delete()->from('users')->where('username = ?', 'peter');]]>
				</programlisting>
			</example>
			<note>
				Each time <methodname>select()</methodname>, <methodname>insertInto()</methodname>, <methodname>update()</methodname> or
				<methodname>delete()</methodname> are called, the query is reseted.
			</note>
			<para>
				You can define a table prefix for all queries using the static method <methodname>setDefaultTablePrefix()</methodname>.
			</para>
		</sect2>
		<sect2 id="db-query-execute">
			<title>Executing the query</title>
			<para>
				You can get the generated sql using <methodname>toSql()</methodname> or using the object in a string context (echoing
				for example).
			</para>
			<para>
				If you're using parameters in your query, they won't be included in the sql string (the question mark, or the key will
				be kept). All parameters can be retrieved using <methodname>getParams()</methodname>.
			</para>
			<example>
				<title>Executing the query against a PDO object</title>
				<programlisting>
					<![CDATA[
$stmt = $pdo->prepare($query->toSql());
$stmt->execute($query->getParams());]]>
				</programlisting>
			</example>
			<para>
				However, this can be simplified by simply calling the <methodname>execute()</methodname> method of the query object
				with a PDO object as argument.
			</para>
			<example>
				<title>Executing a query</title>
				<programlisting>
					<![CDATA[
$result = $query->execute($pdo);]]>
				</programlisting>
			</example>
			<para>
				When using this method, the result is returned as a <classname>Atomik_Db_Query_Result</classname> object that will
				cover in the next section.
			</para>
			<para>
				You can also pass query objects to <methodname>Atomik_Db_Instance::query()</methodname> without the need to specify
				the parameters as second argument.
			</para>
			<example>
				<title>Executing a query with <methodname>Atomik_Db_Instance::query()</methodname></title>
				<programlisting>
					<![CDATA[
$result = $instance->query($query);]]>
				</programlisting>
			</example>
			<para>
				You can define a parameter at any time using <methodname>setParam()</methodname>.
			</para>
			<para>
				It is also possible to define a pdo object for a query using <methodname>setPdo()</methodname> or a default pdo
				object for all queries using the <methodname>setDefaultPdo()</methodname> static method. In this case, it's not needed to pass
				a pdo object to <methodname>execute()</methodname>.
			</para>
		</sect2>
		<sect2 id="db-query-result">
			<title>Manipulating query results</title>
			<para>
				Rather than directly returning the PDOStatement object, <methodname>Atomik_Db_Query::execute()</methodname> returns
				an <classname>Atomik_Db_Query_Result</classname> object. The reason is that PDOStatement can only be iterate over once
				whereas the result object can be iterate as anytime you want.
			</para>
			<para>
				For the most part, result objects work the same way as PDOStatement and have the same methods. However, one of the
				main differences is that the fetch mode can only be set before any rows are fetched. This is to ensure that all
				cached data are coherent.
			</para>
			<para>
				As a result of the previous condition, the <methodname>fetch()</methodname> method does not have a fetch mode
				argument.
			</para>
			<example>
				<title>Iterating over results</title>
				<programlisting>
					<![CDATA[
while ($row = $result->fetch()) {
	// do something
}]]>
				</programlisting>
				<programlisting>
					<![CDATA[
foreach ($result as $row) {
 // do something
}]]>
				</programlisting>
				<programlisting>
					<![CDATA[
for ($i = 0; $i < $result->rowCount(); $i++) {
	$row = $result[$i];
}]]>
				</programlisting>
			</example>
			<para>
				You can check if the data have already been fetched using <methodname>isCached()</methodname>. You can also reload the
				data using <methodname>reload()</methodname> (this will re-execute the query and reset the result object).
			</para>
			<para>
				<methodname>fetchAll()</methodname> is also available. There's also an alias method named <methodname>toArray()</methodname>.
				Note that <methodname>fetchColumn()</methodname> is not available.
			</para>
			<para>
				You can still access the PDOStatement using <methodname>getStatement()</methodname> (unless the query is cached) and the
				associated query using <methodname>getQuery()</methodname>.
			</para>
		</sect2>
		<sect2 id="db-query-cache">
			<title>Caching queries</title>
			<para>
				We've seen that query result can be queried over many times without re-executing the query. But what about the same query being
				executed multiple times. <classname>Atomik_Db_Query</classname> allows you to cache queries so the same query with the
				same parameters won't be executed a second time.
			</para>
			<para>
				For a query to be cached, call <methodname>setCacheable()</methodname> with true as argument. You can also specify to cache
				all queries by default using the static method <methodname>setCacheAllQueries()</methodname>.
			</para>
			<para>
				You can check if query result are cached using <methodname>isCached()</methodname> or empty the cache using
				<methodname>emptyCache()</methodname>.
			</para>
		</sect2>
	</sect1>
</chapter>
