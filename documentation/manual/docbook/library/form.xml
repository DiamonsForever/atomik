<?xml version="1.0" encoding="UTF-8"?>
<chapter id="form" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>Form</title>
	<para>
		The Atomik_Form component provide facilities to create and handle forms.
	</para>
	<para>
		The forms is made of fields. Each fields render itself and handle its data.
		The whole form is rendered using two templates: one for fields and one for the form tag. This way
		you can only render fields if needed.
	</para>
	<sect1 id="form-creation">
		<title>Creating a form</title>
		<para>
			Creating forms is pretty straightforward. Everything is done using the <classname>Atomik_Form</classname>
			class.
		</para>
		<example>
			<title>Creating a form</title>
			<programlisting>
				<![CDATA[
$form = new Atomik_Form();]]>
			</programlisting>
		</example>
		<para>
			Forms can have a name. Naming your forms is not very important for most use but can become very useful
			when dealing with sub forms...
		</para>
		<para>
			Note that if a form has a name, all its data will be stored in an array named like the form.
		</para>
		<para>
			You can specify attributes of the form tag using <methodname>setAttributes()</methodname> or
			<methodname>setAttribute()</methodname>. There are also some shortcut accessors for common attributes
			like the id, method, action and enctype.
		</para>
	</sect1>
	<sect1 id="form-fields">
		<title>Form fields</title>
		<para>
			Fields are defined as classes which must implement <classname>Atomik_Form_Field_Interface</classname>.
			A bunch of fields are built-in under the <classname>Atomik_Form_Field_</classname> namespace.
		</para>
		<sect2 id="form-field-create">
			<title>Using fields</title>
			<para>
				You must specify a name for each fields as the first argument of the constructor.
			</para>
			<example>
				<title>Instanciating a field</title>
				<programlisting>
					<![CDATA[
$field = new Atomik_Form_Field_Input('name');]]>
				</programlisting>
			</example>
			<para>
				You can create fields using <methodname>Atomik_Form_Field_Factory::factory()</methodname>. This method
				takes as first argument a built-in field name or a full class name. The built-in field name is the part
				after the last underscore in the class name (eg. Input can be used for Atomik_Form_Field_Input).
				The second and third arguments are the same as the first and second arguments of fields constructor.
			</para>
			<example>
				<title>Instanciating a field using the factory</title>
				<programlisting>
					<![CDATA[
$field = Atomik_Form_Field_Factory::factory('Input', 'name');]]>
				</programlisting>
			</example>
		</sect2>
		<sect2 id="form-field-add">
			<title>Adding fields to a form</title>
			<para>
				You can use the <methodname>addField()</methodname> method of the form object to add some fields.
				It takes as first argument a field object and optionally the label string as second argument.
			</para>
			<example>
				<title>Adding a field to a form</title>
				<programlisting>
					<![CDATA[
$field = Atomik_Form_Field_Factory::factory('Input', 'name');
$form->addField($field, 'Name');]]>
				</programlisting>
			</example>
			<para>
				You can also set the label later using the <methodname>setLabel()</methodname> method of the form object.
			</para>
			<example>
				<title>Setting a field's label</title>
				<programlisting>
					<![CDATA[
$form->setLabel($field, 'Name');]]>
				</programlisting>
			</example>
			<para>
				There are also methods to remove, reset and get all fields.
			</para>
		</sect2>
		<sect2 id="form-field-options">
			<title>Field's accessors</title>
			<para>
				First of all you can set or get the name of the field using <methodname>setName()</methodname> and 
				<methodname>getName()</methodname>.
			</para>
			<para>
				The value of the field can be defined using <methodname>setValue()</methodname> and retrieve using
				<methodname>getValue()</methodname>. Beware that the value passed to the setter can be different than
				the one retrieved.
			</para>
			<para>
				Fields subclassing <classname>Atomik_Form_Field_Abstract</classname> (should be most of them, all built-in
				ones at least) also provide some methods to handle options. They all come from <classname>Atomik_Options</classname>
				as the abstract class inherit from that one.
			</para>
			<para>
				Options can be specified as an array in the second argument of the constructor.
			</para>
			<para>
				Each type of field can have custom options. However, they all share common ones to define validation logic.
				Validation is covered in the next section.
			</para>
			<example>
				<title>Field's accessors</title>
				<programlisting>
					<![CDATA[
$field = new Atomik_Form_Field_Input('name');

$field->setName('username');
echo $field->getName();

$field->setValue('peter');
echo $field->getValue();

$field->setOption('name', 'value');
echo $field->getOptions();]]>
				</programlisting>
			</example>
		</sect2>
		<sect2 id="form-field-validation">
			<title>Validating field's value</title>
			<note>
				This is only available for fields sublclassing <classname>Atomik_Form_Field_Abstract</classname>.
			</note>
			<para>
				Validating fields is one of the most (if not the most) important part of the whole form process!
				PHP's filter extension is used for that purpose.
			</para>
			<para>
				Some fields are said to be required, ie. they must be defined. To specify a field as such, simply
				set the <quote>required</quote> option to true.
			</para>
			<para>
				The <quote>validate</quote> option allow you to use a regexp or a PHP's filter name which will be used to validate
				the field. Regexp must be specified between slashes. Modifiers can also be used.
			</para>
			<note>
				See <link xlink:href="http://php.net/manual/filter.constants.php">http://php.net/manual/filter.constants.php</link> 
				for a complete list of filters.
			</note>
			<example>
				<title>Specifying fields validation options</title>
				<programlisting>
					<![CDATA[
$field = new Atomik_Form_Field_Input('name', array(
	'required' => 'true',
	'validate' => 'validate_email' // ie. FILTER_VALIDATE_EMAIL
));]]>
				</programlisting>
			</example>
			<para>
				If you prefer using a custom function to handle validation you can use the <quote>validate_with</quote> options which
				takes a callback string as value. The callback must take the field's value as argument and return either true or false.
			</para>
			<example>
				<title>Using a custom validator</title>
				<programlisting>
					<![CDATA[
function my_validator($value) {
	return !empty($value);
}

$field = new Atomik_Form_Field_Input('name', array(
	'validate-with' => 'my_validator'
));]]>
				</programlisting>
			</example>
		</sect2>
	</sect1>
	<sect1 id="form-rendering">
		<title>Rendering forms</title>
		<para>
			Atomik_Form allows you to render the whole form (fields and the form tag) or only the fields. The last way is the default
			one and can be achieved by calling <methodname>render()</methodname> or simply echoing the form object.
		</para>
		<para>
			To render the whole form, you'll need to call <methodname>renderForm()</methodname>.
		</para>
		<example>
			<title>Rendering form fields</title>
			<programlisting>
				<![CDATA[
<form action="handler.php" method="post">
	<?= $form ?>
	<input type="submit" value="Send" />
</form>]]>
			</programlisting>
		</example>
		<example>
			<title>Rendering the whole form</title>
			<programlisting>
				<![CDATA[
<?= $form->renderForm() ?>]]>
			</programlisting>
		</example>
		<sect2 id="form-rendering-template">
			<title>Templates</title>
			<para>
				Forms use templates to render themselves. There are two kind of templates: for the fields and for the form. The first one
				is used to wrap the field in a more prettier form (commonly to display the associated label). The second one is used
				to render the form tag and form buttons.
			</para>
			<para>
				Using these two kind of templates allows you to either render the whole form or only the fields. When using the second
				approach, you can customize the form when including it in your view.
			</para>
			<para>
				You can set the form template using <methodname>setFormTemplate()</methodname> and the field template using
				<methodname>setFieldTemplate()</methodname>. There are also two static methods to define the default templates for all
				forms: <methodname>Atomik_Form::setDefaultFormTemplate()</methodname> and <methodname>Atomik_Form::setDefaultFieldTemplate()</methodname>.
				Each of these methods takes a filename as argument.
			</para>
			<para>
				The component comes with three templates: one using p, another using ul and one using dl. They're available under
				<filename>Atomik/Form/Template</filename>. The default template is Dl.
			</para>
			<example>
				<title>Setting a form template</title>
				<programlisting>
					<![CDATA[
$form1->setFormTemplate('Atomik/Form/Template/P.php');
$form1->setFieldTemplate('Atomik/Form/Template/Field/P.php');

$form2->setFormTemplate('Atomik/Form/Template/Li.php');
$form2->setFieldTemplate('Atomik/Form/Template/Field/Li.php');

$form3->setFormTemplate('Atomik/Form/Template/Dl.php');
$form3->setFieldTemplate('Atomik/Form/Template/Field/Dtdd.php');]]>
				</programlisting>
			</example>
		</sect2>
	</sect1>
	<sect1 id="form-data">
		<title>Handling form data</title>
		<para>
			You can check if a form has data (ie. the form has been submitted) using <methodname>hasData()</methodname>.
			Once you know there are data, you should validate them. This is done using <methodname>isValid()</methodname>.
			If the validation fails, you can retreive an array of error messages using <methodname>getValidationMessages()</methodname>.
			Finally, you can retreive the data using <methodname>getData()</methodname>.
		</para>
		<example>
			<title>Handling form data</title>
			<programlisting>
				<![CDATA[
if ($form->hasData()) {
	if (!$form->isValid()) {
		$messages = $form->getValidationMessages();
		// do something with $messages
	} else {
		$data = $form->getData();
		// do something with the data
	}
}]]>
			</programlisting>
		</example>
	</sect1>
	<sect1 id="form-class">
		<title>Creating forms using classes</title>
		<para>
			It is pretty painful to define forms using all these objects and method calls. Atomik Form provides a nice way to do that
			using classes and doc comments.
		</para>
		<para>
			To do so, create a class that extend <classname>Atomik_Form_Class</classname>. The class public properties will be used
			as form fields. You can specify field's options using doc comment tags. You can also specify form's attributes using the
			class doc comment.
		</para>
		<example>
			<title>Defining a form using a class</title>
			<programlisting>
				<![CDATA[
/**
 * @action user/login
 * @method POST
 */
class MyForm extends Atomik_Form_Class
{
	/**
	 * @label Username
	 * @required
	 */
	public $username;
	
	/**
	 * @label Password
	 * @required
	 */
	public $password;
}]]>
			</programlisting>
		</example>
		<para>
			When there are some data available, you can access them through the public properties.
		</para>
		<example>
			<title>Using a form class</title>
			<programlisting>
				<![CDATA[
$form = new MyForm();

if ($form->hasData() && $form->isValid()) {
	echo $form->username . ' ' . $form->password;
}

echo $form->renderForm();]]>
			</programlisting>
		</example>
		<note>
			It is also possible to create forms using any classes with <methodname>Atomik_Form_Class::create()</methodname>.
			This method takes as first argument a class name and optionally as second a prefix for doc comment tags name.
		</note>
	</sect1>
	<sect1 id="form-sub">
		<title>Sub forms</title>
		<para>
			It is sometimes needed to create multipage forms or to embed a form into another. Atomik_Form makes it easy to do
			such things as you can add a form to another like any field.
		</para>
		<para>
			Note that to do that, it is greatly advice to name forms. Doing so avoids confusion between data of the different
			forms.
		</para>
		<example>
			<title>Adding a form to another</title>
			<programlisting>
				<![CDATA[
$mainForm = new Atomik_Form();
$subForm1 = new Atomik_Form('sub1');
$subForm2 = new Atomik_Form('sub2');

$mainForm->addField($subForm1);
$mainForm->addField($subForm2);

echo $mainForm->renderForm();]]>
			</programlisting>
		</example>
		<para>
			You can then choose to render the main form (as shown in the example) or each forms independently. You can also
			validate them in the same way.
		</para>
	</sect1>
	<sect1 id="form-custom-fields">
		<title>Creating custom fields</title>
		<para>
			As said before, fields are defined as classes. To create a custom one, you must implement the 
			<classname>Atomik_Form_Field_Interface</classname>. The easiest way is two subclass <classname>Atomik_Form_Field_Abstract</classname>
			which already implements nearly all methods from the interface. You'll only need to write the <methodname>render()</methodname>
			method.  
		</para>
		<para>
			You must use <methodname>getFullname()</methodname> to get the field's name.
		</para>
		<example>
			<title>Creating a custom field</title>
			<programlisting>
				<![CDATA[
class MyField extends Atomik_Form_Field_Abstract
{
	public function render()
	{
		return sprintf('<input type="text" maxlength="10" name="%s" %s />',
			$this->getFullname(),
			$this->getOptionsAsAttributeString()
		);
	}
}]]>
			</programlisting>
		</example>
		<para>
			You could also override the <methodname>setValue()</methodname> and <methodname>getValue()</methodname> methods to
			handle the data in a specific way.
		</para>
	</sect1>
</chapter>
