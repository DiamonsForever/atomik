<?xml version="1.0" encoding="UTF-8"?>
<chapter id="utilities" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>Utilities</title>
	<sect1 id="utilities-redirect-404">
		<title>Redirections and 404 errors</title>
		<para>
			To redirect the user to another page you can use the <methodname>Atomik::redirect()</methodname> method.
			It takes as argument the url to redirect to. By default, this url will first be process using 
			<methodname>Atomik::url()</methodname>. This behaviour can be disabled by passing false as the second argument.
			The response HTTP code can also be specified as the third argument.
		</para>
		<example>
			<title>Redirecting</title>
			<programlisting>
				<![CDATA[
Atomik::redirect('home');
Atomik::redirect('home', true, 303); // 303 http code]]>
			</programlisting>
		</example>
		<para>
			Triggering 404 errors is even simpler. Just call the <methodname>Atomik::trigger404()</methodname> method.
			Customization of the 404 error page has been discussed in the configuration chapter.
		</para>
		<example>
			<title>Trigerring a 404 error</title>
			<programlisting>
				<![CDATA[
Atomik::trigger404();]]>
			</programlisting>
		</example>
	</sect1>
	<sect1 id="utilities-escape">
		<title>Escaping text</title>
		<para>
			It is a common (and very good) practice to escape data when outputting it on the page.
			The <methodname>Atomik::escape()</methodname> method is dedicated to this purpose.
		</para>
		<example>
			<title>Escaping text</title>
			<programlisting>
				<![CDATA[
echo Atomik::escape('my text');]]>
			</programlisting>
		</example>
		<para>
			This method relies on other functions to escape data. It simply executes them one after an other 
			and returns the result. You can for example, execute the <function>htmlspecialchars()</function> 
			function followed by <function>nl2br()</function>.
		</para>
		<para>
			The functions to execute are grouped under profiles. Thus, you can create multiple escaping profiles 
			depending on the data you need to escape. Profiles are defined in the <quote>app/escaping</quote> 
			configuration key. To specify which functions to execute in a profile, you can use a string or an 
			array of strings. Functions will be executed in the order they appear in the array.
			The default profile is called <quote>default</quote>.
		</para>
		<para>
			The profile is specified as the last argument of the method.
		</para>
		<example>
			<title>Escaping text using different profiles</title>
			<programlisting>
				<![CDATA[			
// creating profiles
Atomik::set('app/escaping', array(
	'default' => array('htmlspecialchars', 'nl2br'),
	'url' => 'urlencode'
));

// equivalent of nl2br(htmlspecialchars('my text'))
echo Atomik::escape('my text');

// equivalent of urlencode('my url param')
echo Atomik::escape('my url param', 'url');]]>
			</programlisting>
		</example>
	</sect1>
	<sect1 id="utilities-friendlify">
		<title>Friendly urls</title>
		<para>
			Having a router without a way to make friendly urls woudln't be a complete feature. 
			<methodname>Atomik::friendlify()</methodname> transforms string to a url friendly version.
		</para>
		<example>
			<title>Make an url friendly string</title>
			<programlisting>
				<![CDATA[
echo Atomik::friendlify('My text in the url');
// will echo my-text-in-the-url]]>
			</programlisting>
		</example>
	</sect1>
	<sect1 id="utilities-filter">
		<title>Filtering and validating data</title>
		<para>
			Filtering and validating user input is a very important task and Atomik had to provide a method for
			this purpose. This method is <methodname>Atomik::filter()</methodname> and it heavily relies on 
			PHP's filter extension.
		</para>
		<note>
		    <para>
			    PHP's filter extension is built-in since version 5.2. Prior to that, you must use PECL. More information
			    is available in the extension documentation at <link xlink:href="http://php.net/filter">http://php.net/filter</link>.
			</para>
			<para>
			    You can find a good documentation (better than the official one) about available filters on the w3schools
			    website at <link xlink:href="http://www.w3schools.com/php/php_ref_filter.asp">http://www.w3schools.com/php/php_ref_filter.asp</link>
			</para>
		</note>
		<para>
			To understand and use <methodname>Atomik::filter()</methodname> you must know how to use PHP's filter
			extension. However, Atomik's method adds some features.
		</para>
		<para>
			<methodname>Atomik::filter()</methodname> has the same arguments as <function>filter_var()</function>.
			However, you can also use a regular expression as filter in the second argument. The regexp must use
			slashes as delimiters. You can also define custom filters in the <quote>app/filters/callbacks</quote>
			configuration key and use the callback name as filter.
		</para>
		<example>
			<title>Filtering data</title>
			<programlisting>
				<![CDATA[
// using a php filter
$result = Atomik::filter('me@example.com', PHP_VALIDATE_EMAIL);
$result = Atomik::filter('me@example.com', 'validate_email'); // using the filter name instead of its id
$result = Atomik::filter('example.com', FILTER_VALIDATE_URL, FILTER_FLAG_SCHEME_REQUIRED);

// using a regexp
$result = Atomik::filter('12478', '/\d+/');

// using a callback
Atomik::set('app/filters/callbacks/my_custom_filter', 'myFilterFunction');
$result = Atomik::filter($data, 'my_custom_filter');]]>
			</programlisting>
		</example>
		<para>
			It will return false if an error occured, or the value otherwise.
		</para>
		<para>
			The method can also be used to filter arrays in the same way as <function>filter_var_array()</function>. It works
			exactly the same as this function but it also adds more features.
		</para>
		<para>
			The method will return false if any of the item failed to validate. This can be turned off by passing
			false as the fourth argument.
		</para>
		<para>
			While the second argument is named a definition in the PHP's extension, Atomik called it a rule. 
			Rules are arrays where keys are field's name and their value a filter or an array 
			(like with <function>filter_var_array()</function>). You can pass a rule as the second argument. 
			Rules can also be defined in the <quote>app/filters/rules</quote> configuration key. 
			You can then use their name instead of an array as the second argument.
		</para>
		<para>
			The method also adds the notion of required fields. If you set the <quote>required</quote> key to true in 
			the field's array, the validation will fail if the field is missing or empty. 
		</para>
		<para>
			When a field is empty but not required, its value will be null. This can be changed by setting 
			the <quote>default</quote> key in the field's array.
		</para>
		<para>
			The filter key in the field's array follows the same rule as the filter parameter described previously. 
			Thus it can be a filter's id or name, a regexp or a custom filter's name.
		</para>
		<para>
			The method also support multi-dimension array as input.
		</para>
		<para>
			Finally, support for validation messages has also been added. When filtering the array, if any values 
			failed validating, a message will be created. Messages can then be retreived in the 
			<quote>app/filters/messages</quote> configuration key. There is two default messages configured in 
			<quote>app/filters/default_message</quote> and <quote>app/filters/required_message</quote>.
			The former will be used when a field failed to validate while the later when the required condition has not been met.
		</para>
		<note>
			When setting the two message keys, you can use <quote>%s</quote> which will be replaced with the field's name. 
			As field names aren't usually pretty, you can use the <quote>label</quote> key in the field's array to define 
			the text which will be used to replace <quote>%s</quote>.
		</note>
		<para>
			You can override the failed to validate message for each field by setting the <quote>message</quote> 
			key in the field's array.
		</para>
		<example>
			<title>Filtering arrays</title>
			<programlisting>
				<![CDATA[
// using a custom message when a field is missing or empty
Atomik::set('app/filters/required_message', 'You forgot to fill the %s field!');

// the data to validate
$dataToFilter = array(
	'username' => 'peter',
	'email' => 'peter@example.com'
);

// our rule
$rule = array(
	'username' => array(
		'filter' => FILTER_SANITIZE_STRING,
		'required' => true
	),
	'email' => array(
		'filter' => 'validate_email',
		'required' => true,
		'message' => 'You must provide a valid email address' // custom message when the field failed to validate
	)
);

if (($filteredData = Atomik::filter($dataToFilter, $rule)) === false) {
	// failed validation, showing messages
	Atomik::flash(A('app/filters/messages'), 'error');
	return;
}

// success
// do something with $filteredData]]>
			</programlisting>
		</example>
	</sect1>
	<sect1 id="utilities-path">
		<title>Managing paths</title>
		<para>
			Atomik provides a single powerful method to manage paths: <methodname>Atomik::path()</methodname>.
		</para>
		<para>
			The method can be use in two differente ways. First to retreive a path or an array of path.
			In this case the first argument should be a set of paths (a string or an array containing paths). 
			If only the first argument is given, the result will be a string containing the first path of the set.
			If the second argument is set to true, an array of paths will be returned.
		</para>
		<example>
			<title>Using <methodname>Atomik::path()</methodname> with paths</title>
			<programlisting>
				<![CDATA[
echo Atomik::path('/tmp/data'); // /tmp/data
echo Atomik::path(array('/tmp/data', /tmp/data2')); // /tmp/data

paths = Atomik::path('/tmp/data', true); // array('/tmp/data')
$paths = Atomik::path(array('/tmp/data', /tmp/data2'), true); // array('/tmp/data', /tmp/data2')]]>
			</programlisting>
		</example>
		<para>
			The same method can also be use to find the pathname of a file. In this case, the first argument
			must be a string containing the file's name. The second argument must be a set of paths (a string
			or an array).
		</para>
		<para>
			The method will search in paths from the set of paths and return the first found file with the
			file name provided as the first argument. If no file is found, false is returned.
		</para>
		<para>
			It is possible to avoid checking for the file existence by passing false as the third argument.
			This will however always return the file as if it was in the first path of the set of paths.
		</para>
		<example>
			<title>Using <methodname>Atomik::path()</methodname> to find files</title>
			<programlisting>
				<![CDATA[
$pathname = Atomik::path('my-file.txt', array('/path1', '/path2')); // /path1/my-file.txt if the file is located in /path1 (/path2 otherwise)
$pathname = Atomik::path('my-file.txt', '/path1'); // /path1/my-file.txt
]]>
			</programlisting>
		</example>
	</sect1>
</chapter>
