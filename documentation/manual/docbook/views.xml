<?xml version="1.0" encoding="UTF-8"?>
<chapter id="views-layouts" xmlns="http://docbook.org/ns/docbook">
	<title>Views and layouts</title>
	<sect1 id="views">
		<title>Views</title>
		<para>
			Views are stored in the <filename>app/views</filename> directory. The file extension is
			by default <quote>phtml</quote>.
		</para>
		<para>
			The content of a view file is, as the action file, free. It should mostly be text or 
			HTML (or any presentation content, such as XML).
		</para>
		<para>
			PHP can be used to print variables from the action or to provide presentation logic like
			loops.
		</para>
		<example>
			<title>Example of a view</title>
			<programlisting>
				<![CDATA[
<html>
	<head>
		<title>Example</title>
	</head>
	<body>
		<?= $myPublicVariable; ?>
	</body>
</html>]]>
			</programlisting>
		</example>
		<tip>
		    If your configuration allows it, it is better to use php's short tags in views for better readibility.
		</tip>
		<figure>
			<title>A little schema to sum up!</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata format="PNG" fileref="images/actions_views.png" />
				</imageobject>
			</mediaobject>
		</figure>
	</sect1>
	<sect1 id="helpers">
		<title>Helpers</title>
		<para>
			When creating your views, you'll often need to execute the same piece of logic many time. Formating a date
			for example. An helper is exactly that: a function that you can reuse in your views; <function>format_date()</function>
			for example.
		</para>
		<sect2 id="creating-helpers">
			<title>Creating helpers</title>
			<para>
				Helpers in Atomik are stored in <filename>app/helpers</filename>. Our <quote>format_date</quote> helper would 
				be stored in <filename>app/helpers/format_date.php</filename>. The helpers directory can be changed using
				<quote>atomik/dirs/helpers</quote>.
			</para>
			<para>
				You can then define your helper in two ways: as a function or a class. If you're using a function, 
				just create one with the same name as the helper. For our <quote>format_date</quote> helper, the 
				function would be <function>format_date()</function>.
				But you can also use a class which can be pretty useful for more complex ones. The class name is a 
				camel case version (ie. without any underscores or spaces, all words starting with an upper case) 
				of the helper name suffixed with <quote>Helper</quote>. In our example, it would be 
				<classname>FormatDateHelper</classname>. This class also needs to have a method named like the 
				helper name but in camel case and starting with a lower case. In this case, it would be 
				<methodname>formatDate()</methodname>.
			</para>
			<example>
				<title>Creating an helper</title>
				<para>
					As a function
				</para>
				<programlisting>
					<![CDATA[
function format_date($date)
{
	// do the formating
	return $date;
}]]>
				</programlisting>
				<para>
					Or as a class
				</para>
				<programlisting>
					<![CDATA[
class FormatDateHelper
{
	public function formatDate($date)
	{
		// do the formating
		return $date;
	}
}]]>
				</programlisting>
			</example>
		</sect2>
		<sect2 id="using-helpers">
			<title>Using helpers</title>
			<para>
				Helpers are callable from any file that is being rendered. That is to say views, 
				layouts or any file rendered using <methodname>Atomik::renderFile</methodname>.
				They are accessible as methods of <varname>$this</varname>. Helpers are automatically loaded.
			</para>
		    <note>
		        Helpers are also available in the same way from actions, but there are meant to be use from views.
		    </note>
			<example>
				<title>Calling an helper</title>
				<programlisting>
					<![CDATA[
<span class="date"><?= $this->format_date('01-01-2009') ?></span>]]>
				</programlisting>
			</example>
		</sect2>
	</sect1>
	<sect1 id="layouts">
		<title>Layout</title>
		<para>
			It is common in websites that all pages share the same layout. Atomik allows you to define
			a layout that will be used with all views.
		</para>
		<para>
			The layout will be rendered after the view has been rendered. The output of the view will be
			pass to the layout as a variable named <varname>$contentForLayout</varname>. 
			Layouts are rendered the same way as views.
		</para>
		<para>
			Layouts can be placed in the <filename>app/views</filename> or <filename>app/layouts</filename> directories.
			The file extension is the same as the one for views.
		</para>
		<para>
			The layout name to use has to be defined in the <quote>app/layout</quote> configuration key. If the
			value is false (which is the default), no layout will be used.
		</para>
		<para>
			The layout can be disabled at runtime by calling <methodname>Atomik::disableLayout()</methodname>.
			It can later be re-enabled by passing false as argument to the same method.
		</para>
		<example>
			<title>Example layout</title>
			<para>
				A layout file named <filename>_layout.phtml</filename> in the <filename>app/views</filename> directory.
			</para>
			<programlisting>
				<![CDATA[
<html>
	<head>
		<title>My website</title>
	</head>
	<body>
		<h1>My website</h1>
		<div id="content">
			<?= $contentForLayout; ?>
		</div>
	</body>
</html>]]>
			</programlisting>
			<para>
				In the bootstrap file
			</para>
			<programlisting>
				<![CDATA[
Atomik::set('app/layout', '_layout');]]>
			</programlisting>
		</example>
		<para>
			Mutliple layouts can also be used. Just use an array instead of a string in the configuration key. Layouts will
			be rendered in reverse order (the first one in the array wrap the second, the second the third, ...).
		</para>
	</sect1>
	<sect1 id="view-contexts">
		<title>View contexts</title>
		<para>
			It is sometimes needed to return content in different formats. Rather than creating multiple actions doing the
			same thing, Atomik allows you to create a view for each content type. This is called view contexts. The correct
			view is rendered depending on the current context.
		</para>
		<para>
			The context is defined using a route parameter. By default it is called <quote>format</quote>. This can be changed in
			<quote>app/views/context_param</quote>. As specified in the urls chapter, the format parameter is by default the
			file extension. Which means that using an url like <link>index.xml</link> will result in using the xml context.
		</para>
		<para>
			The default view context is <quote>html</quote> but it can be changed in <quote>atomik/views/default_context</quote>.
		</para>
		<para>
			To create a view for a context just suffix the view name with the context name like an extension. For example, let's
			say we have an <quote>article</quote> view. The filename for the xml context would be <filename>article.xml.phtml</filename>.
			Some context may not need any prefix like the <quote>html</quote> one.
		</para>
		<para>
			Depending on the view context, the layout can be disabled and the response content-type can be changed. The file
			prefix can also be specified. All of this is done in <quote>app/views/contexts</quote>.
		</para>
		<example>
			<title>Creating a custom view context</title>
			<para>
				Let's create the <quote>rdf</quote> context.
			</para>
			<programlisting>
				<![CDATA[
Atomik::set('app/views/contexts/rdf', array(    // the context name, ie. the file extension in the url
	'prefix'        => 'rdf',                   // the view's file extension prefix (set to false for no prefix)
	'layout'        => false,                   // whether to enable the layout
	'content-type'  => 'application/xml+rdf'    // the response content type
));]]>
			</programlisting>
			<para>
				Now you can call an url like <link>http://example.com/article.rdf</link>. In this case the view filename
				would be <filename>article.rdf.phtml</filename>, the layout would be disabled and the response content type
				would be <quote>application/xml+rdf</quote>.
			</para>
		</example>
		<para>
			If a view context is not defined under <quote>app/views/contexts</quote>, the file prefix will be the context name,
			the layout won't be disabled and the response content type will be <quote>text/html</quote>.
		</para>
		<para>
			By default, four contexts are defined: html, ajax, xml and json. The ajax context is the same as html but with 
			the layout disabled. The last two disable the layout and set the appropriate content type.
		</para>
	</sect1>
	<sect1 id="controlling-views">
		<title>Controlling views</title>
		<sect2 id="view-extension">
			<title>View's filename extension</title>
			<para>
				The default filename's extension for views is <quote>phtml</quote> as said before. This can be change using
				the configuration key named <quote>app/views/file_extension</quote>.
			</para>
		</sect2>
		<sect2 id="no-render-from-action">
			<title>Do not render the view from the action</title>
			<para>
				While the action is executing, you may want to avoid rendering the associated view. This can easily be done
				by calling <methodname>Atomik::noRender()</methodname> from your action.
			</para>
		</sect2>
		<sect2 id="modify-associated-view">
			<title>Modify the associated view from the action</title>
			<para>
				While the action is executing, you may want to render a different view. In this case, you can use
				<methodname>Atomik::setView()</methodname> from your action. It takes as unique argument a view name.
			</para>
		</sect2>
		<sect2 id="custom-rendering-engine">
			<title>Using a custom rendering engine</title>
			<para>
				The default rendering process only uses php's include function. You may however want to use a template engine for
				example. This is possible by specifying a callback in the <quote>app/views/engine</quote> configuration key.
			</para>
			<para>
				The callback will receive two parameters: the first one will be the filename and the second an array containing the
				view variables.
			</para>
			<example>
				<title>Using a custom rendering engine</title>
				<programlisting>
					<![CDATA[
function myCustomRenderingEngine($filename, $vars)
{
	// your custom engine
	return $renderedContent;
}

Atomik::set('app/views/engine', 'myCustomRenderingEngine');]]>
				</programlisting>
			</example>
			<para>
				The custom rendering engine will be used whenever <methodname>Atomik::render()</methodname>,
				<methodname>Atomik::renderFile()</methodname> or <methodname>Atomik::renderLayout()</methodname> is used.
			</para>
		</sect2>
	</sect1>
	<sect1 id="views-programmatically">
		<title>Rendering views programmatically</title>
		<para>
			When executing a request, the action and/or the view associated to it are
			automatically called. You can however render other views using Atomik's API.
		</para>
		<para>
			The most useful use of this it to render partial views, small part of presentation
			code that is reusable.
		</para>
		<para>
			To render a view use the <methodname>Atomik::render()</methodname> method.
		</para>
		<para>
			It takes as first argument the view name and optionally as second argument
			an array of key/value pairs representing variables. 
			The method returns the view output.
		</para>
		<example>
			<title>Rendering a view programmatically</title>
			<programlisting>
				<![CDATA[
$viewOutput = Atomik::render('myView');
$viewOutput = Atomik::render('myView', array('var' => 'value'));]]>
			</programlisting>
		</example>
		<para>
			It is also possible to render any file using <methodname>Atomik::renderFile()</methodname>. It takes
			as first parameter a filename. Variables can also be passed like with <methodname>Atomik::render()</methodname>.
		</para>
		<note>
			You can also render contextual views by adding the file extension prefix to the view name.
		</note>
	</sect1>
</chapter>
